import list;

def BinSema(acquired):
    result = dict{ .acquired: acquired, .suspended: [] };
;
def Lock():
    result = BinSema(False);
;
def acquire(lk):
    atomic:
        if lk->acquired:
            stop lk->suspended;
            assert lk->acquired;
        else:
            lk->acquired = True;
        ;
    ;
;
def release(lk):
    atomic:
        if lk->suspended == []:
            lk->acquired = False;
        else:
            go (list.head(lk->suspended)) ();
            lk->suspended = list.tail(lk->suspended);
        ;
    ;
;
def Condition(lk):
    result = [];
;
def wait(c, lk):
    atomic:
        release(lk);
        stop !c;
    ;
    acquire(lk);
;
def notify(c):
    atomic:
        if !c != []:
            go (list.head(!c)) ();
            !c = list.tail(!c);
        ;
    ;
;
def notifyAll(c):
    atomic:
        while !c != []:
            go (list.head(!c)) ();
            !c = list.tail(!c);
        ;
    ;
;
def Semaphore(cnt):
    result = dict{ .count: cnt, .waiters: [] };
;
def P(sema):
    atomic:
        if (!sema).count > 0:
            (!sema).count -= 1;
        else:
            stop (!sema).waiters;
        ;
    ;
;
def V(sema):
    atomic:
        let cnt, waiters = (!sema).count, (!sema).waiters:
            if waiters != []:
                assert cnt == 0;
                go (waiters[0]) ();
                (!sema).waiters = list.tail(waiters);
            else:
                (!sema).count = cnt + 1;
            ;
        ;
    ;
;
def Queue():
    result = dict{ .list: [], .waiters: [] };
;
def dequeue(q):
    atomic:
        let list = q->list:
            if list == []:
                stop q->waiters;
            ;
            result = list.head(list);
            q->list = list.tail(list);
        ;
    ;
;
def enqueue(q, item):
    atomic:
        q->list = list.append(q->list, item);
        let waiters = q->waiters:
            if waiters != []:
                go (waiters[0]) item;
                q->waiters = list.tail(waiters);
            ;
        ;
    ;
;
